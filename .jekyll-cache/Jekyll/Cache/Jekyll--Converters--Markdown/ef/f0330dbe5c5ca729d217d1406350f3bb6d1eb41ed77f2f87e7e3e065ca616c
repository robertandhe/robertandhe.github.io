I"ގ<p>最近开始复习机器学习知识，这里总结下聚类里面的Kmeans算法。</p>
<h2 id="1-理论介绍">1. 理论介绍</h2>
<h3 id="11-kmeans理论介绍">1.1 KMeans理论介绍</h3>
<p> K-平均算法（英文：k-means clustering）源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘领域。k-平均聚类的目的是：把n个点（可以是样本的一次观察或一个实例）划分到k个聚类中，使得每个点都属于离他最近的均值（此即聚类中心）对应的聚类，以之作为聚类的标准。这个问题将归结为一个把数据空间划分为Voronoi cells的问题。<br />
 给定样本集<script type="math/tex">D=\left\{x_1,x_2,...,x_m\right\}</script>
，k-means算法针对聚类所得簇划分
<script type="math/tex">\Omega=\left\{C_1,C_2,...,C_k\right\}</script>
最小化平方误差</p>

<script type="math/tex; mode=display">E = \sum\limits_{i = 1}^k {\sum\limits_{x \in {C_i}} {\left\| {x - {\mu _i}} \right\|_2^2} }</script>

<p> 其中${\mu_i}=\frac{1}{\left|{C_i} \right|}\sum\nolimits_{x\in{C_i}}x$是簇$C_i$的均值向量。$E$刻画了簇内样本围绕簇均值向量的紧密程度，$E$越小则簇内样本相似度越高。
最小化$E$需要考察样本集$D$所有可能的簇划分，这是一个NP难问题。因此，k均值算法采用了贪心策略，通过迭代优化来近似求解。算法流程如下图所示：
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-01-15/kmeansAlg.PNG" alt="kmeansAlg" height="80%" width="80%" /></p>
<blockquote>
  <p>注：来自周志华《机器学习第九章p.203》</p>
</blockquote>

<p>可以看出KMeans算法中有几个关键要素：</p>
<ol>
  <li>K值选择：一般根据对数据的先验经验选择一个合适的K值，或者通过交叉验证选择一个合适的K值；</li>
  <li>距离度量：常用欧式距离，曼哈顿距离等；</li>
  <li>初始质心选择：初始质心对最后聚类结果有较大影响。</li>
</ol>

<h3 id="12-kmeans变体">1.2 KMeans变体</h3>
<h4 id="121-kmeans初始化优化kmeans">1.2.1 KMeans初始化优化KMeans++</h4>
<p> k个初始化质心的位置的选择对最后的聚类结果和运行时间都有很大的影响，需要选择合适的质心。如果随机选择，有可能导致算法收敛很慢。KMeans++算法就是对KMeans随机初始化质心的方法的优化。
 原理如下：</p>
<ul>
  <li>从输入的数据点集合中随机选择一个点作为第一个聚类中心${\mu_1}$;</li>
  <li>对于数据集中的每一个点$x_i$，计算它与已选择的聚类中心中<strong>最近聚类中心</strong>的距离</li>
</ul>

<script type="math/tex; mode=display">D(x_i) = argmin\left\|{x_i-\mu _r} \right\|_2^2,r = 1,2,...,{k_{selected}}</script>

<ul>
  <li>选择一个新的数据作为新的聚类中心，选择原则：$D(x)$较大的点被选取作为聚类中心的概率较大；</li>
  <li>重复2，3步直到选择出K个聚类中心；</li>
  <li>利用这K个质心作为初始化质心去运行标准的KMeans算法。</li>
</ul>

<h4 id="122-kmeans距离计算优化elkan-kmeans">1.2.2 KMeans距离计算优化elkan KMeans</h4>
<p> 在传统的KMeans算法中，每轮迭代中，要计算所有样本点到所有质心的距离，这个过程比较耗时，如何优化？。elkan KMeans算法就是从这块入手加以改进。它的目标是减少不必要的距离计算。何为不必要的距离计算？<br />
 elkan KMeans利用了三角形两边之和大于等于第三边以及两边之差小于第三边的性质。</p>
<ul>
  <li>对于一个样本点$x$和两个质心${\mu_i}$和${\mu_j}$，如果预先计算出了两个质心的距离$D(j_1, j_2)$,则如果计算发现$2D\left({x,j_1}\right) \le D\left({j_1,j_2} \right)$，就可知$D\left({x,j_1}\right) \le D\left( {x,{j_2}} \right)$。此时就不需要计算$D(x, j_2)$。</li>
  <li>对于一个样本点$x$和两个质心${\mu_i}$和${\mu_j}$。可以得到<script type="math/tex">D(x,j_2)\ge\max\left\{0,D(x,j_1)-D(j_1,j_2)\right\}</script>。</li>
</ul>

<p> 利用上边两个规律，elkan KMeans比起传统的KMeans迭代速度有了很大提高。但如果样本特征是稀疏的，有缺失值的话，这个方法就不适用了。</p>

<h4 id="123-大样本优化mini-batch-kmeans">1.2.3 大样本优化Mini Batch KMeans</h4>
<p> 在统的K-Means算法中，要计算所有的样本点到所有的质心的距离。如果样本量非常大，比如达到10万以上，特征有100以上，此时用传统的K-Means算法非常的耗时，就算加上elkan K-Means优化也依旧。在大数据时代，这样的场景越来越多。此时Mini Batch K-Means应运而生。<br />
 顾名思义，Mini Batch，也就是用样本集中的一部分的样本来做传统的K-Means，这样可以避免样本量太大时的计算难题，算法收敛速度大大加快。当然此时的代价就是我们的聚类的精确度也会有一些降低。一般来说这个降低的幅度在可以接受的范围之内。</p>

<h3 id="13-kmeans优缺点">1.3 KMeans优缺点</h3>
<h4 id="131-优点">1.3.1 优点</h4>
<p> KMeans的主要优点有：</p>
<ul>
  <li>原理简单，实现容易，收敛速度快；</li>
  <li>聚类效果较优；</li>
  <li>算法可解释性比较强；</li>
  <li>主要调参的参数仅为簇数K</li>
</ul>

<h4 id="132-缺点">1.3.2 缺点：</h4>
<p> KMeans的主要缺点有：</p>
<ul>
  <li>K值得选取不好把握；</li>
  <li>对于不是凸的数据集比较难收敛；</li>
  <li>如果各隐含类别的数据不平衡，则聚类效果不佳；</li>
  <li>采用迭代方法，得到的结果可能只是局部最优；</li>
  <li>对噪声和异常值敏感。</li>
</ul>

<h2 id="2-c实现">2. c++实现</h2>
<p>kmeans.h文件</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">pointId</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">clusterId</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dimensions</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pointId</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">is</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">){</span>
            <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="o">++</span><span class="n">dimensions</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">clusterId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//Output id of each cluster is 1, 2, ...</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getDimensions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">dimensions</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getCluster</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">clusterId</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getID</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">pointId</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setCluster</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clusterId</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">getVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Cluster</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">clusterId</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">centroid</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Cluster</span><span class="p">(</span><span class="kt">int</span> <span class="n">clusterId</span><span class="p">,</span> <span class="n">Point</span> <span class="n">centroid</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">clusterId</span> <span class="o">=</span> <span class="n">clusterId</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">centroid</span><span class="p">.</span><span class="n">getDimensions</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">centroid</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">centroid</span><span class="p">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">addPoint</span><span class="p">(</span><span class="n">centroid</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">addPoint</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="p">.</span><span class="n">setCluster</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">clusterId</span><span class="p">);</span>
        <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">removePoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">pointId</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getID</span><span class="p">()</span> <span class="o">==</span> <span class="n">pointId</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">points</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getId</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">clusterId</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Point</span> <span class="n">getPoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getSize</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">getCentroidByPos</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">centroid</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setCentroidByPos</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">double</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">centroid</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">KMeans</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">K</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iters</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dimensions</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">total_points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cluster</span><span class="o">&gt;</span> <span class="n">clusters</span><span class="p">;</span>

    <span class="cm">/**
     * @description: Find the nearest cluster centroid, return it's id for input point 
     * @param point: point for clustering
     * @return: nearest cluster id
     */</span>    
    <span class="kt">int</span> <span class="n">getNearestClusterId</span><span class="p">(</span><span class="n">Point</span> <span class="n">point</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nearestClusterId</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getCentroidByPos</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">);</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
        <span class="n">nearestClusterId</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getId</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getCentroidByPos</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">);</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">){</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
                <span class="n">nearestClusterId</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getId</span><span class="p">();</span>
            <span class="p">}</span>

        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nearestClusterId</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">public:</span>
    <span class="n">KMeans</span><span class="p">(</span><span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">iters</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">run</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">all_points</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">total_points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getDimensions</span><span class="p">();</span>
        
        <span class="c1">// Initializing Clusters;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">used_pointIds</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">total_points</span><span class="p">;</span>   
                <span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">used_pointIds</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">used_pointIds</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">used_pointIds</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
                    <span class="n">used_pointIds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
                    <span class="n">all_points</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">setCluster</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="n">Cluster</span> <span class="n">cluster</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">all_points</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
                    <span class="n">clusters</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Clusters initialized = "</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Running KMeans Clustering.."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iter - "</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">iters</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="c1">// Add all points to their nearest cluster</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">total_points</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">currentClusterId</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getCluster</span><span class="p">();</span>
                <span class="kt">int</span> <span class="n">nearestClusterId</span> <span class="o">=</span> <span class="n">getNearestClusterId</span><span class="p">(</span><span class="n">all_points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">currentClusterId</span> <span class="o">!=</span> <span class="n">nearestClusterId</span><span class="p">){</span>
                    <span class="c1">// currentClusterId = 0 for the first running </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">currentClusterId</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">getId</span><span class="p">()</span> <span class="o">==</span> <span class="n">currentClusterId</span><span class="p">)</span>
                                <span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">removePoint</span><span class="p">(</span><span class="n">all_points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getID</span><span class="p">());</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">getId</span><span class="p">()</span> <span class="o">==</span> <span class="n">nearestClusterId</span><span class="p">)</span>
                            <span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">addPoint</span><span class="p">(</span><span class="n">all_points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="n">all_points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setCluster</span><span class="p">(</span><span class="n">nearestClusterId</span><span class="p">);</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Update the center of each cluster</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">ClusterSize</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getSize</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">ClusterSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">ClusterSize</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
                            <span class="n">sum</span> <span class="o">+=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getPoint</span><span class="p">(</span><span class="n">p</span><span class="p">).</span><span class="n">getVal</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                        <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setCentroidByPos</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">ClusterSize</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">|</span> <span class="n">iter</span> <span class="o">&gt;</span> <span class="n">iters</span><span class="p">){</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Clustering completed in iteration : "</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Print pointIds in each cluster</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Points in cluster "</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getPoint</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">getID</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Write cluster centers to file</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
        <span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"clustersCenter.txt"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">outfile</span><span class="p">.</span><span class="n">is_open</span><span class="p">()){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cluster "</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" centroid: "</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getCentroidByPos</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
                    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getCentroidByPos</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">outfile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fatal error: Unable to write to clustersCenter.txt"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h3 id="测试一下"><strong>测试一下</strong>：</h3>
<p>kmeansTest.cpp主文件：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="cp">#include "kmeans.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Error: command-line argument count mismatch."</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">infile</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">infile</span><span class="p">.</span><span class="n">is_open</span><span class="p">()){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Error: Failed to open file."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//Fetching points from file</span>
    <span class="kt">int</span> <span class="n">pointId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">all_points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">line</span><span class="p">)){</span>
        <span class="n">Point</span> <span class="n">point</span><span class="p">(</span><span class="n">pointId</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
        <span class="n">all_points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
        <span class="o">++</span><span class="n">pointId</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">infile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Data fetched successfully!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Return if number of clusters &gt; number of points</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">all_points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Error: Number of clusters greater than number of points."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">KMeans</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">iters</span><span class="p">);</span>
    <span class="n">kmeans</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">all_points</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输入为data.txt,包括
9 9<br />
1 1<br />
-1 -1<br />
3 3<br />
10 10<br />
-2 -2<br />
7 8<br />
0.2 0<br />
-1 0<br />
6 10<br />
命令行输入，输出为
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-01-15/kmeansTest.PNG" alt="kmeansTest" height="80%" width="80%" /></p>

<h2 id="3-python实现">3. python实现</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">KMeans</span><span class="p">():</span>
    <span class="s">"""class for kmeans clustering algorithm"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">filePath</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="o">=</span> <span class="n">filePath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="s">'''
    @description: read file to numpy matrix
    @param {filename: open file path} 
    @return: numpy matrix
    '''</span>
    <span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">curLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
            <span class="n">fltLine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">curLine</span><span class="p">))</span>
            <span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fltLine</span><span class="p">)</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataMat</span><span class="p">)</span>
        <span class="c1"># self.dataSet = dataMat
</span>        <span class="k">return</span> <span class="n">dataMat</span>

    <span class="k">def</span> <span class="nf">distEclud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">vecA</span> <span class="o">-</span> <span class="n">vecB</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">randCent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">minJ</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">maxJ</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">rangeJ</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxJ</span> <span class="o">-</span> <span class="n">minJ</span><span class="p">)</span>
            <span class="n">centroids</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">minJ</span> <span class="o">+</span> <span class="n">rangeJ</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">centroids</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distMeasure</span><span class="o">=</span><span class="n">distEclud</span><span class="p">,</span> <span class="n">createCent</span><span class="o">=</span><span class="n">randCent</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dataSet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'filePath is None and dataSet not provided'</span>
            <span class="n">dataSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filePath</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">clusterAssment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">createCent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">clusterChanged</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">minDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">minIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">distJI</span> <span class="o">=</span> <span class="n">distMeasure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="k">if</span> <span class="n">distJI</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">:</span>
                        <span class="n">minDist</span> <span class="o">=</span> <span class="n">distJI</span>
                        <span class="n">minIndex</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">if</span> <span class="n">clusterAssment</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">minIndex</span><span class="p">:</span>
                    <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">clusterAssment</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">minDist</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">print</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cent</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">ptsInClust</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cent</span><span class="p">]</span>
                <span class="n">centroids</span><span class="p">[</span><span class="n">cent</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ptsInClust</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">iter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Iteration times reach max_iter </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">=</span> <span class="nb">iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centers_</span>  <span class="o">=</span> <span class="n">centroids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inertia_</span> <span class="o">=</span> <span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">clusterAssment</span>

    <span class="k">def</span> <span class="nf">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">all_or_any</span><span class="o">=</span><span class="nb">all</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">"This </span><span class="si">%(name)</span><span class="s">s instance is not fitted yet. Call 'fit' with "</span>
                   <span class="s">"appropriate arguments before using this method."</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">'fit'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="s">"This is not an estimator instance."</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_or_any</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testData</span><span class="p">,</span> <span class="n">disMeature</span><span class="o">=</span><span class="n">distEclud</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_is_fitted</span><span class="p">(</span><span class="s">'cluster_centers_'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Computing label assignment and total inertia"</span><span class="p">)</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">testData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
        <span class="n">distanceMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">distanceMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">disMeature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testData</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distanceMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">labels</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="测试一下-1"><strong>测试一下</strong>：</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">kmeans</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">'kmeansTest.txt'</span><span class="p">)</span>
<span class="n">myCentroids</span><span class="p">,</span> <span class="n">clusterAssing</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输出为：
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-01-15/kmeansTestMyPy.PNG" alt="kmeansTestMyPython" height="80%" width="80%" /></p>

<h2 id="4-sklearn包实现">4. sklearn包实现</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输出为：
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-01-15/kmeansTestPython.PNG" alt="kmeansTestPython" height="80%" width="80%" /></p>

<p>可以看出三种实现方式运行结果一样，符合预期。</p>

<h2 id="5-后续">5. 后续</h2>
<ul>
  <li>python版本KMeans实现-done[2020-01-16 18:46]</li>
  <li>KMeans与GMM联系</li>
  <li>其余聚类算法实现</li>
</ul>

<h2 id="6-bisecting-kmeans">6. bisecting KMeans</h2>
<p> 当KMeans初始质心选择不当时可能会收敛到局部极小值，可以对生成的簇进行后处理，此时可以选择：</p>
<ul>
  <li>合并最近的质心；</li>
  <li>合并两个使得SSE增幅最小的质心。</li>
</ul>

<p> 所以有人提出了二分K-均值(bisecting KMeans)算法，该算法首先将所有点作为一个簇，然后将该簇一分为二。之后选择其中一个簇继续进行划分，选择哪一个簇进行划分取决于对齐划分是否可以最大程度降低SSE的值。上述基于SSE的划分过程不断重复，直到得到用户指定的簇数目为止。<br />
 python实现：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">BiKMeans</span><span class="p">():</span>
    <span class="s">"""class for bikmeans clustering algorithm"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">filePath</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="o">=</span> <span class="n">filePath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="s">'''
    @description: read file to numpy matrix
    @param {filename: open file path} 
    @return: numpy matrix
    '''</span>
    <span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">curLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">fltLine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">curLine</span><span class="p">))</span>
            <span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fltLine</span><span class="p">)</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataMat</span><span class="p">)</span>
        <span class="c1"># self.dataSet = dataMat
</span>        <span class="k">return</span> <span class="n">dataMat</span>

    <span class="k">def</span> <span class="nf">distEclud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">vecA</span> <span class="o">-</span> <span class="n">vecB</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">randCent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">minJ</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">maxJ</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">rangeJ</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxJ</span> <span class="o">-</span> <span class="n">minJ</span><span class="p">)</span>
            <span class="n">centroids</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">minJ</span> <span class="o">+</span> <span class="n">rangeJ</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">centroids</span>

    <span class="k">def</span> <span class="nf">kmeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distMeasure</span><span class="o">=</span><span class="n">distEclud</span><span class="p">,</span> <span class="n">createCent</span><span class="o">=</span><span class="n">randCent</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">clusterAssment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">createCent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">clusterChanged</span><span class="p">:</span>
            <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">minDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">minIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">distJI</span> <span class="o">=</span> <span class="n">distMeasure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="k">if</span> <span class="n">distJI</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">:</span>
                        <span class="n">minDist</span> <span class="o">=</span> <span class="n">distJI</span>
                        <span class="n">minIndex</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">if</span> <span class="n">clusterAssment</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">minIndex</span><span class="p">:</span>
                    <span class="n">clusterChanged</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">clusterAssment</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">minDist</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cent</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">ptsInClust</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cent</span><span class="p">]</span>
                <span class="n">centroids</span><span class="p">[</span><span class="n">cent</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ptsInClust</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">clusterAssment</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distMeasure</span><span class="o">=</span><span class="n">distEclud</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dataSet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'filePath is None and dataSet not provided'</span>
            <span class="n">dataSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filePath</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">clusterAssment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">centroid0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dataSet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cenList</span> <span class="o">=</span> <span class="p">[</span><span class="n">centroid0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">clusterAssment</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">distMeasure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroid0</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cenList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">lowerestSSE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cenList</span><span class="p">)):</span>
                <span class="n">ptsInCurrCluster</span> <span class="o">=</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">]</span>
                <span class="n">centroidMat</span><span class="p">,</span> <span class="n">splitClustAss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">ptsInCurrCluster</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">distMeasure</span><span class="p">)</span>
                <span class="n">sseSplit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">splitClustAss</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">sseNotSplit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">clusterAssment</span><span class="p">[</span><span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"sseSplit, and notSplit: "</span><span class="p">,</span> <span class="n">sseSplit</span><span class="p">,</span> <span class="n">sseNotSplit</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sseSplit</span> <span class="o">+</span> <span class="n">sseNotSplit</span> <span class="o">&lt;</span> <span class="n">lowerestSSE</span><span class="p">):</span>
                    <span class="n">bestCentToSplit</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">bestNewCents</span> <span class="o">=</span> <span class="n">centroidMat</span>
                    <span class="n">bestClustAss</span> <span class="o">=</span> <span class="n">splitClustAss</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">lowerestSSE</span> <span class="o">=</span> <span class="n">sseSplit</span> <span class="o">+</span> <span class="n">sseNotSplit</span>
            <span class="n">bestClustAss</span><span class="p">[</span><span class="n">bestClustAss</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cenList</span><span class="p">)</span>
            <span class="n">bestClustAss</span><span class="p">[</span><span class="n">bestClustAss</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bestCentToSplit</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"The bestCentToSplit is: "</span><span class="p">,</span> <span class="n">bestCentToSplit</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"The len of bestClustAss is: "</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bestClustAss</span><span class="p">))</span>
            <span class="n">cenList</span><span class="p">[</span><span class="n">bestCentToSplit</span><span class="p">]</span> <span class="o">=</span> <span class="n">bestNewCents</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">cenList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bestNewCents</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">clusterAssment</span><span class="p">[</span><span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">bestCentToSplit</span><span class="p">]</span> <span class="o">=</span> <span class="n">bestClustAss</span>
        <span class="n">cenArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cenList</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centers_</span> <span class="o">=</span> <span class="n">cenArr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inertia_</span> <span class="o">=</span> <span class="n">clusterAssment</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cenArr</span><span class="p">,</span> <span class="n">clusterAssment</span>

    <span class="k">def</span> <span class="nf">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">all_or_any</span><span class="o">=</span><span class="nb">all</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">"This </span><span class="si">%(name)</span><span class="s">s instance is not fitted yet. Call 'fit' with "</span>
                   <span class="s">"appropriate arguments before using this method."</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">'fit'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="s">"This is not an estimator instance."</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_or_any</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testData</span><span class="p">,</span> <span class="n">disMeature</span><span class="o">=</span><span class="n">distEclud</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_is_fitted</span><span class="p">(</span><span class="s">'cluster_centers_'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Computing label assignment and total inertia"</span><span class="p">)</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">testData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
        <span class="n">distanceMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">distanceMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">disMeature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testData</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distanceMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">labels</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="7-reference">7. reference</h2>
<p><a href="https://github.com/aditya1601/kmeans-clustering-cpp">kmeans-github</a>  <br />
<a href="https://www.cnblogs.com/pinard/p/6164214.html">刘建平Pinard - K-Means聚类算法原理</a> <br />
《机器学习-周志华》<br />
《机器学习实战-第十章》</p>
:ET