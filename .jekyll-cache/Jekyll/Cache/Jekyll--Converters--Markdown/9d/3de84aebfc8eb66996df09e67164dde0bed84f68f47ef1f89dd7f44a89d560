I"<h2 id="1-dbscan理论介绍">1. DBSCAN理论介绍</h2>
<p> DBSCAN(Density-Based Spatial Clustering of Applicaions with Noise,具有噪声的基于密度的聚类方法)是一种很典型的聚类算法，和KMeans,BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。</p>
<h3 id="11-密度聚类原理">1.1 密度聚类原理</h3>
<p> DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间是紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p>
<h3 id="12-dbscan密度定义">1.2 DBSCAN密度定义</h3>
<p> DBSCAN基于一组邻域参数$\left( {\varepsilon ,MinPts} \right)$来刻画样本分布的紧密程度。给定数据集<script type="math/tex">{\rm{D}} = \left\{ x_1,x_2,...,x_m\right\}</script>，定义下面几个概念：</p>
<ul>
  <li>$\varepsilon$-邻域：对${x_j} \in D$，其$\varepsilon$-邻域包含样本集$D$中与$x_j$的距离不大于$\varepsilon$的样本，即
<script type="math/tex">N_\varepsilon(x_j)=\left\{x_i\in D|dist(x_i,x_j)\le\varepsilon\right\}</script>
;</li>
  <li>核心对象(core object): 若$x_j$的$\varepsilon$-邻域至少包含$MinPts$个样本，即
<script type="math/tex">|{N_\varepsilon(x_j)}| \ge MinPts</script>
，则$x_j$是一个核心对象；</li>
  <li>密度直达(directly density-reachable): 若$x_j$位于$x_i$的$\varepsilon$-邻域中，且$x_i$是核心对象，则称$x_j$由$x_i$密度直达；</li>
  <li>密度可达(density-reachable): 对$x_i$与$x_j$，若存在样本序列${p_1},{p_2},…,{p_n}$，其中$p_1=x_i,p_n=x_j$且$p_{i+1}$由$p_i$密度直达，则称$x_j$由$x_i$密度可达；</li>
  <li>密度相连(density-connected): 对$x_i$与$x_j$, 若存在$x_k$使得$x_i$与$x_j$均由$x_k$密度可达，则称x_i$与$x_j$密度相连。</li>
</ul>

<p> 基于这些概念，DBSCAN将“簇”定义为：由密度可达关系导出的最大的密度相连样本集合。</p>

<p> 那么怎么才能找到这样的簇样本集合？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到了另一个聚类簇。一直运行到所有核心对象都有类别为止。</p>

<p> 基本上这就是DBSCAN算法的主要内容，但还有三个问题要考虑。<br />
 第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象周围，在DBCSAN中，我们一般将这些样本点标记为噪音点。<br />
 第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采样最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。<br />
 第三个问题比较特殊，某些样本可能到两个核心对象的距离都小于$\varepsilon$，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如何界定这个样本的类别呢？一般来说DBSCAN采用先来后到，先进行聚类的类别簇会标记为这个样本的类别。也就是说DBSCAN算法不是完全稳定的算法。</p>

<h3 id="13-dbscan算法">1.3 DBSCAN算法</h3>

<p><img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-02-01/dbscanAlg.PNG" alt="kmeansAlg" height="80%" width="80%" /></p>
<blockquote>
  <p>注：来自周志华《机器学习第九章p.213》</p>
</blockquote>

<h3 id="14-dbscan小结">1.4 DBSCAN小结</h3>
<p> 和传统的KMeans算法相比，DBSCAN最大的不同就是不需要输入类别数k，它最大的优势是可以发现任意形状的聚类簇，而不是像KMeans一般仅仅适用于凸的样本聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。
那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么DBSCAN会比KMeans聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。<br />
 DBSCAN的主要优点有：</p>
<ul>
  <li>可以对任意形状的稠密数据集进行聚类，相对的，KMeans之类的算法一般只适用于凸数据集；</li>
  <li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感；</li>
  <li>聚类结果没有偏倚，相对的，KMeans之类的聚类算法初始值对聚类结果有很大影响。</li>
</ul>

<p> DBSCAN的主要缺点有：</p>
<ul>
  <li>如果样本集的密度不均匀，聚类间距差相差很大是，聚类质量较差，这时用DBSCAN聚类一般不适合；</li>
  <li>如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进；</li>
  <li>调参相对于传统的KMeans之类的聚类算法稍复杂，主要需要对距离阈值$\varepsilon$，邻域样本数阈值$MinPts$联合调参，不同的参数组合对最后的聚类效果有较大影响。</li>
</ul>

<h2 id="2-c实现">2. C++实现</h2>
<h3 id="21-c代码">2.1 C++代码</h3>
<p>dbscan.h文件</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
</span>
<span class="k">class</span> <span class="nc">PointDB</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">feature</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pointCnt</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cluster</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">getDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">PointDB</span><span class="o">&amp;</span> <span class="n">ot</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">feature</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ot</span><span class="p">.</span><span class="n">feature</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ot</span><span class="p">.</span><span class="n">feature</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DBSCAN</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DBSCAN</span><span class="p">(</span><span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minPts</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointDB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">);</span>
    <span class="n">DBSCAN</span><span class="p">(</span><span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minPts</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">);</span>
    <span class="o">~</span><span class="n">DBSCAN</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">normalizeFeature</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">feature</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">run</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clusterId</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">checkNearPoints</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">isCoreObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">getCluster</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getPointsCluster</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">getNumCluster</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">minPts</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">eps</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointDB</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adjPoints</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">cluster</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">clusterIdx</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NOISE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NOT_CLASSIFIED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>    
<span class="p">};</span>


<span class="n">DBSCAN</span><span class="o">::</span><span class="n">DBSCAN</span><span class="p">(</span><span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minPts</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointDB</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">minPts</span> <span class="o">=</span> <span class="n">minPts</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="n">adjPoints</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">clusterIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">DBSCAN</span><span class="o">::</span><span class="n">DBSCAN</span><span class="p">(</span><span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minPts</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&amp;</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointDB</span><span class="o">&gt;</span> <span class="n">tPoints</span><span class="p">(</span><span class="n">features</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">localFeature</span> <span class="o">=</span> <span class="n">normalizeFeature</span><span class="p">(</span><span class="n">features</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">localFeature</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="n">tPoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">feature</span> <span class="o">=</span> <span class="n">localFeature</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tPoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pointCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tPoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">NOT_CLASSIFIED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">minPts</span> <span class="o">=</span> <span class="n">minPts</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">points</span> <span class="o">=</span> <span class="n">tPoints</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">adjPoints</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">clusterIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">DBSCAN</span><span class="o">::~</span><span class="n">DBSCAN</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">normalizeFeature</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&amp;</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">instance_num</span> <span class="o">=</span> <span class="n">features</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">feature_num</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">feature_num</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">({</span> <span class="p">{</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">}</span> <span class="p">}));</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">feature_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">instance_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">features</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">features</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">features</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">feature_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">checkNearPoints</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getDistance</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pointCnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">adjPoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">isCoreObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">pointCnt</span> <span class="o">&gt;=</span> <span class="n">minPts</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clusterIdx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">points</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">clusterIdx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isCoreObject</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">next</span> <span class="o">:</span> <span class="n">adjPoints</span><span class="p">[</span><span class="n">now</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="n">cluster</span> <span class="o">!=</span> <span class="n">NOT_CLASSIFIED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">clusterIdx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">checkNearPoints</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span> <span class="o">!=</span> <span class="n">NOT_CLASSIFIED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isCoreObject</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">clusterIdx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span> <span class="o">=</span> <span class="n">NOISE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cluster</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">clusterIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span> <span class="o">!=</span> <span class="n">NOISE</span><span class="p">)</span>
			<span class="n">cluster</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">noiseIdx</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span> <span class="o">==</span> <span class="n">NOISE</span><span class="p">)</span>
			<span class="n">noiseIdx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">noiseIdx</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cluster</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">noiseIdx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">row</span> <span class="o">:</span> <span class="n">cluster</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="n">row</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"total cnt "</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">getCluster</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cluster</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">getPointsCluster</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pointCluster</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">pointCluster</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cluster</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pointCluster</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">DBSCAN</span><span class="o">::</span><span class="n">getNumCluster</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">clusterIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="22-c测试">2.2 C++测试</h3>
<p>main.cpp文件</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include "dbscan.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">".</span><span class="se">\\</span><span class="s">dbscanTest2.txt"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"fatal error！ unable to open file"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">stringstream</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ins</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">row</span><span class="p">;</span>
		<span class="kt">double</span> <span class="n">t</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ins</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">row</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">row</span><span class="p">);</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"data size: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">in</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
	<span class="n">DBSCAN</span> <span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">dbscan</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dbscan</span><span class="p">.</span><span class="n">getCluster</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">row</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"new cluster:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">:</span> <span class="n">row</span><span class="p">)</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输出为
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-02-01/cppTest.PNG" alt="cppTest" /></p>

<h2 id="3-python实现">3. python实现</h2>
<h3 id="31-python代码">3.1 python代码</h3>
<p>dbscan.py文件</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="k">class</span> <span class="nc">DBSCAN</span><span class="p">():</span>
    <span class="s">"""class for dbscan clustering algorithm"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">minPts</span><span class="p">,</span> <span class="n">filePath</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPts</span> <span class="o">=</span> <span class="n">minPts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="o">=</span> <span class="n">filePath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearNeighbors</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">curLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">fltLine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">curLine</span><span class="p">))</span>
            <span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fltLine</span><span class="p">)</span>
        <span class="n">dataMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataMat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataMat</span>

    <span class="k">def</span> <span class="nf">calDist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">getNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Find neighbors of "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calDist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">normalizeFeature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">):</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">checkNearObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)):</span>
            <span class="n">newArr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calDist</span><span class="p">(</span><span class="n">dataSet</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dataSet</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">newArr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newArr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearNeighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isCoreObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nearNeighbors</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minPts</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">notAccess</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">notAccess</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isCoreObject</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearNeighbors</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">notAccess</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">notAccess</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataSet</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dataSet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'filePath is None and dataSet is not provide'</span>
            <span class="n">dataSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadDataSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filePath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span> <span class="o">=</span> <span class="n">dataSet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizeFeature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizeFeature</span><span class="p">(</span><span class="n">dataSet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkNearObject</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span><span class="p">)</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="p">{}</span>    
        <span class="n">instanceNum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataSet</span><span class="p">)</span>
        <span class="n">notAccess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">instanceNum</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">clusterIdx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">instanceNum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">notAccess</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isCoreObject</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">notAccess</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="n">cluster</span><span class="p">[</span><span class="n">clusterIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">clusterIdx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">noiseArr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">instanceNum</span><span class="p">):</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">notAccess</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">noiseArr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">noiseArr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cluster</span><span class="p">[</span><span class="n">clusterIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">noiseArr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_</span> <span class="o">=</span> <span class="n">cluster</span>
        <span class="k">return</span> <span class="n">cluster</span>
    
    <span class="k">def</span> <span class="nf">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">all_or_any</span><span class="o">=</span><span class="nb">all</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">"This </span><span class="si">%(name)</span><span class="s">s instance is not fitted yet. Call 'fit' with "</span>
                   <span class="s">"appropriate arguments before using this method."</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">'fit'</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="s">"This is not an estimator instance"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_or_any</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">{</span><span class="s">'name'</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">})</span>


    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testData</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_is_fitted</span><span class="p">(</span><span class="s">'cluster_'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Predict the class of test data"</span><span class="p">)</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">testData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">core</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_</span><span class="p">[</span><span class="n">core</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calDist</span><span class="p">(</span><span class="n">testData</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">return</span> <span class="n">labels</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h3 id="32-python测试">3.2 python测试</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">dbscan</span> <span class="kn">import</span> <span class="n">DBSCAN</span>

<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">filePath</span><span class="o">=</span><span class="s">'./dbscan/dbscanTest2.txt'</span><span class="p">)</span>
<span class="n">cluster</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输出为
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-02-01/pythonTest.PNG" alt="pythonTest" /></p>

<h2 id="4-sklearn库">4. sklearn库</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'./dbscan/dbscanTest2.txt'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">' '</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">dbscan</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>输出为
<img src="https://gitee.com/alston972/MarkDownPhotos/raw/master/2020-02-01/skDbscanTest.PNG" alt="skDbscanTest" /></p>

<p> <strong>可以看出三种实现方式运行结果一样，符合预期</strong></p>

<h2 id="5-reference">5. Reference</h2>
<p><a href="https://www.cnblogs.com/pinard/p/6208966.html">DBSCAN密度聚类算法-刘建平</a><br />
<a href="https://github.com/bowbowbow/DBSCAN/blob/master/clustering.cpp">DBSCAN-cpp-github</a><br />
《机器学习第九章-周志华》</p>

:ET